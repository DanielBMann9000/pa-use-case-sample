<!DOCTYPE html>
<html>
  <head>
    <meta charset=utf-8 />
    <title>PreEmptive Analytics .Net Client User Guide</title>
    <style media="print">
    body {
      font-size: 80%;
    }
    </style>
    <style>
    body {
      font-family: Helvetica, Arial, sans-serif;
      line-height: 1.5;
    }
    h1,
    h2,
    h3,
    p.sample {
      color: #1981c4;
      font-family: 'Doppio One', sans-serif;
    }
    #header {
      padding-top: 10px;
      padding-bottom: 10px;
      padding-left: 5px;
      min-height: 100px;
      background-color: #1981c4;
      color: #fff;
      page-break-after: avoid;
    }
    #header h1,
    #header h2 {
      color: #fff;
      line-height: 0.75;
    }
    #toc ul,
    #toc li {
      list-style-image: none;
      list-style-type: none;
    }
    #wrapper {
      width: 90%;
      min-width: 40em;
      max-width: 55em;
      margin-left: auto;
      margin-right: auto;
    }
    #content {} p.sample {
      margin-top: 5px;
      margin-bottom: 0px;
      line-height: 0.8;
      font-size: 80%;
      page-break-after: avoid;
    }
    /*code blocks*/
    pre {
      word-wrap: break-word;
      white-space: pre;
      width: auto;
      max-height: 600px;
      overflow: auto;
      background-color: #eee;
      padding-left: 3px;
      padding-top: 5px;
      padding-bottom: 5px;
      page-break-inside: avoid;
    }
    code {
      page-break-before: avoid;
      font-family: Consolas, Menlo, Monaco, 'Lucida Console', 'Courier New', monospace;
      background-color: #eee;
    }
    </style>
  </head>
  <body>
    <div id="wrapper">
      <div id="header">
        <h1>PreEmptive Analytics</h1>
        <h2>.NET Client API v1.2 User's Guide</h2>
      </div>
      <div id="content">
        <div id="toc">
          <ul>
            <li><a href="#overview">Overview</a>
            </li>
            <ul>
              <li><a href="#supported-platforms">Supported Platforms</a>
              </li>
              <li><a href="#assemblies">Assemblies</a>
              </li>
              <li><a href="#message-queuing-and-transmission">Message Queuing and Transmission</a>
              </li>
              <li><a href="#off-line-storage">Off-line Storage</a>
              </li>
              <li><a href="#api-usage-pattern">API Usage Pattern</a>
              </li>
            </ul>
            <li><a href="#adding-analytics">Adding Analytics</a>
            </li>
            <ul>
              <li><a href="#start-up-and-shut-down">Start up and Shut down</a>
              </li>
              <li><a href="#company-and-application-id">Company and Application ID</a>
              </li>
              <li><a href="#application-start">Application Start</a>
              </li>
              <li><a href="#application-stop">Application Stop</a>
              </li>
            </ul>
            <li><a href="#tracking-feature-use">Tracking Feature Use</a>
            </li>
            <ul>
              <li><a href="#feature-ticks">Feature Ticks</a>
              </li>
              <li><a href="#feature-starts-and-stops">Feature Starts and Stops</a>
              </li>
              <li><a href="#feature-start-stop-partitioning">Feature Start/Stop Partitioning</a>
              </li>
            </ul>
            <li><a href="#sending-custom-data">Sending Custom Data</a>
            </li>
            <li><a href="#getting-system-information">Getting System Information</a>
            </li>
            <ul>
              <li><a href="#system-profile">System Profile</a>
              </li>
              <li><a href="#performance-probe">Performance Probe</a>
              </li>
            </ul>
            <li><a href="#reporting-tampering">Reporting Tampering</a>
            </li>
            <li><a href="#reporting-exceptions">Reporting Exceptions</a>
            </li>
            <ul>
              <li><a href="#exception-event-types">Exception Event Types</a>
              </li>
              <li><a href="#reporting-details">Reporting Details</a>
              </li>
            </ul>
            <li><a href="#adding-user-details">Adding User Details</a>
            </li>
            <li><a href="#advanced-configuration">Advanced Configuration</a>
            </li>
            <ul>
              <li><a href="#user-opt-in">User Opt-In</a>
              </li>
              <li><a href="#information-about-your-application">Information About Your Application</a>
              </li>
              <li><a href="#binary-information">Binary Information</a>
              </li>
              <li><a href="#storing-data-offline">Storing Data Offline</a>
              </li>
              <li><a href="#controlling-data-transmission">Controlling Data Transmission</a>
              </li>
              <li><a href="#field-size-limits">Field Size Limits</a>
              </li>
              <li><a href="#shutdown-time-limits">Shutdown Time Limits</a>
              </li>
              <li><a href="#api-language-interoperability">API Language Interoperability</a>
              </li>
              <li><a href="#session-extension-window">Session Extension Window</a>
              </li>
            </ul>
            <li><a href="#invalid-characters">Invalid Characters</a>
            </li>
            <li><a href="#the-flow-controller">The Flow Controller</a>
            </li>
            <ul>
              <li><a href="#controlling-the-transmission-window">Controlling the Transmission Window</a>
              </li>
              <li><a href="#time-to-live">Time To Live</a>
              </li>
              <li><a href="#batch-size-limits">Batch Size Limits</a>
              </li>
              <li><a href="#interactions-with-configuration">Interactions With Configuration</a>
              </li>
            </ul>
            <li><a href="#client-side-logging">Client-Side Logging</a>
            </li>
          </ul>
        </div>
        <h1 id="overview">Overview</h1>
        <h2 id="supported-platforms">Supported Platforms</h2>
        <p>The PreEmptive Analytics .NET API supports most major .NET platforms. This includes:</p>
        <ul>
          <li>.NET 4.0 and up on classic &quot;desktop&quot; Windows (includes servers and ASP.NET)</li>
          <li>Windows Phone 8 Applications</li>
          <li>Windows Store Applications (C# and WinRT supported languages)</li>
          <li>Xamarin</li>
        </ul>
        <p>The <code>PAClient</code> classes exposed for each platform are thread-safe and instance methods can be used freely from multiple threads. All instance methods should return very quickly except for <code>ApplicationStopSync</code>. Messages are added
          to the queue and transmitted/saved on a background thread.</p>
        <h2 id="assemblies">Assemblies</h2>
        <p>There are a total of 7 assemblies that ship with this document.</p>
        <ul>
          <li>PreEmptive.Analytics.Common.dll
            <ul>
              <li>Contains all of the platform-agnostic code of the API. With the exception of WinRT, you&#39;ll want to include a reference to this in your project. It is a portable class library capable of targeting .NET 4.0 and up, Windows Store, Windows
                Phone 8, and Xbox 360</li>
            </ul>
          </li>
          <li>PreEmptive.Analytics.WinPhone8.dll
            <ul>
              <li>The platform specific code for Windows Phone 8. This should be referenced if your project is for Windows Phone 8</li>
            </ul>
          </li>
          <li>PreEmptive.Analytics.WindowsStore.dll
            <ul>
              <li>The platform specific code for Windows Store apps. This should be referenced if your project is written in C#/VB.NET and is for Windows Store</li>
            </ul>
          </li>
          <li>PreEmptiveAnalytics.WinRT.winmd
            <ul>
              <li>The WinRT component wrapper over the WindowsStore assembly. You only need to reference this if your project is for Windows Store and NOT written in C#/VB.NET (you can reference it from C#/VB.NET, but it makes development unnecessarily more
                difficult)</li>
            </ul>
          </li>
          <li>PreEmptive.Analytics.Net.dll
            <ul>
              <li>The platform specific code for &quot;classic&quot; .NET, such as the version that runs on your Windows desktop. You can use this if your project is for Console, Winforms, WPF, ASP.NET and other traditional .NET desktop/server applications.</li>
            </ul>
          </li>
          <li>PreEmptive.Analytics.XamarinAndroid.dll
            <ul>
              <li>The platform specific code for Xamarin Android projects.</li>
            </ul>
          </li>
          <li>PreEmptive.Analytics.XamariniOS.dll
            <ul>
              <li>The platform specific code for Xamarin iOS projects.</li>
            </ul>
          </li>
        </ul>
        <h2 id="message-queuing-and-transmission">Message Queuing and Transmission</h2>
        <p>Messages are not immediately sent to the configured endpoint. The API queues messages and sends them either when a certain amount of time has elapsed, or when a number of messages have accumulated. On platforms where transmission may have a performance
          impact, such as on mobile devices, the transmission of messages can be directly controlled by your program using <a href="#controlling-the-transmission-window">Send Disabled</a>
        </p>
        <p>Message transmission is not guaranteed and messages may be lost. In cases of forced application shutdown or storage limitations the API may be unable to transmit queued messages or store them for off-line transmission. Messages may also be discarded
          if they overflow the API&#39;s queue before they can be transmitted.</p>
        <h2 id="off-line-storage">Off-line Storage</h2>
        <p>Your application is not required to always have network connectivity. By default, the API will store messages locally when the configured endpoint cannot be reached. The messages will automatically be sent and removed from offline storage once
          the endpoint can be reached.</p>
        <h2 id="api-usage-pattern">API Usage Pattern</h2>
        <p>The general usage pattern of the API is:</p>
        <ul>
          <li>A <code>Configuration</code> object is created that defines the company sending the message, the application being reported on, and additional options</li>
          <li>An instance of <code>PAClient</code> is created using the previously created configuration object</li>
          <li>The client begins its session with an <a href="#application-start"><code>ApplicationStart</code></a>
          </li>
          <li>The client requests the transmission of multiple messages which include:
            <ul>
              <li><a href="#feature-ticks"><code>FeatureTick</code></a> to mark the occurrence of a tracked event</li>
              <li><a href="#feature-starts-and-stops"><code>FeatureStart</code></a> and <code>FeatureStop</code> paired messages to record the duration of a tracked event</li>
              <li><a href="#system-profile"><code>SystemProfile</code></a> to report information about the platform</li>
              <li><a href="#performance-probe"><code>PerformanceProbe</code></a> to report CPU and memory usage</li>
            </ul>
          </li>
          <li>The client ends its session with an <a href="#application-stop"><code>ApplicationStop</code></a>
          </li>
        </ul>
        <h1 id="adding-analytics">Adding Analytics</h1>
        <h2 id="start-up-and-shut-down">Start up and Shut down</h2>
        <p>The API is idle until <code>ApplicationStart</code> is called. At this point, the API and queues start and are ready to process messages. They remain ready until <code>ApplicationStop</code> is called. If a message function such as <code>FeatureTick</code> is
          used before the API is ready, it will be treated as a no-operation.</p>
        <p>You will need to choose where you want to put the Application Start and Application Stop. While it is typical to have one of each, you can use multiple Starts and/or multiple Stops depending upon the entry point and exit points to your application.
          Extra calls to Start and Stop don&#39;t nest: it&#39;s the first of each one that defines starting and stopping points of your application.</p>
        <h2 id="company-and-application-id">Company and Application ID</h2>
        <p>To start sending analytic messages you will need two IDs:</p>
        <ol>
          <li>The Company ID</li>
          <li>An Application ID</li>
        </ol>
        <p>If using the Runtime Intelligence endpoint, PreEmptive Solutions should have given you a company ID to use. For other endpoints, the company ID can be any valid GUID. The application ID can also be any valid GUID, but should not usually change
          between versions of your application.</p>
        <p>Both of these values are GUIDs. Your Application ID represents your application across versions and platforms.</p>
        <p>If you are using the Runtime Intelligence endpoint, it is recommended that you use a separate ID for evaluation or trial versions of your application. This is so that you can partition the data. You can combine the information from the two versions
          later using the Runtime Intelligence portal. This does not apply to other endpoints.</p>
        <h2 id="application-start">Application Start</h2>
        <p>The only thing you need to call Application Start is a Company ID and an Application ID. Optionally, you can create the <code>PAClient</code> with a <code>Configuration</code> object, which allows for more advanced configuration options.</p>
        <p class="sample">C# Example</p>
        <pre><code>var client = new PAClient(
&quot;7D2B02E0-064D-49A0-BC1B-4BE4381C62D3&quot;, //company ID
&quot;21EC2020-AAA1-1069-A2DD-08002B30309D&quot;); //application ID
client.ApplicationStart();</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>var analytics = PreEmptive.Analytics.WinRT;
var client = new analytics.PAClient(
&quot;7D2B02E0-064D-49A0-BC1B-4BE4381C62D3&quot;, //company ID
&quot;21EC2020-AAA1-1069-A2DD-08002B30309D&quot;, //application ID 
null); //The logger interface (optional)
client.applicationStart();</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>auto client = ref new PAClient(
&quot;7D2B02E0-064D-49A0-BC1B-4BE4381C62D3&quot;, //company ID
&quot;21EC2020-AAA1-1069-A2DD-08002B30309D&quot;, //application ID
nullptr); //The logger interface (optional)
client-&gt;ApplicationStart();</code></pre>
        <p>Of course, there are many other configuration options you can set. Typical options include:</p>
        <ul>
          <li>Additional Application Information
            <ul>
              <li>Name
                <ul>
                  <li>Version</li>
                  <li>Type</li>
                  <li>Instance ID (serial number)</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Endpoint Information
            <ul>
              <li>Location
                <ul>
                  <li>Use SSL</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>User Privacy Options
            <ul>
              <li>User Opt-In
                <ul>
                  <li>Omit Personal Identifiable Data</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
        <p>After the API has been started with an Application Start, changes to <code>StartupConfiguration</code> values will not affect the API&#39;s behavior.</p>
        <h2 id="application-stop">Application Stop</h2>
        <p>Just before your application terminates you should make a call to Application Stop. This generates the messages that are used to calculate the duration of the user&#39;s interaction with your application and handles any messages queued in memory.</p>
        <p class="sample">C# Example</p>
        <pre><code>client.ApplicationStop();</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>client.applicationStop();</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>client-&gt;ApplicationStop();</code></pre>
        <p>There are several optional arguments you can pass to the Application Stop as well as to most of the other API functions. These are covered in the <a href="#sending-custom-data">Sending Custom Data</a> and <a href="#information-about-your-application">Information About Your Application</a> sections.</p>
        <p>ApplicationStop is synchronous (blocking) on some platforms and asynchronous on other platforms. To override the default behavior of the platform, you can use <code>ApplicationStopAsync</code> and <code>ApplicationStopSync</code>, which is asynchronous
          and synchronous, respectively.</p>
        <h1 id="tracking-feature-use">Tracking Feature Use</h1>
        <p>The most common usage of analytics is to track which features are popular among users and how they interact with them. You can indicate that a feature was used by using the <code>FeatureTick</code> method. You can track the duration of a feature&#39;s
          use by using <code>FeatureStart</code> and <code>FeatureStop</code>.</p>
        <h2 id="feature-ticks">Feature Ticks</h2>
        <p>The <code>FeatureTick</code> method generates a message that the configured endpoint tallies up. All you need to provide is a name that defines the feature:</p>
        <p class="sample">C# Example</p>
        <pre><code>public void ConstructTriangle(int rows)
{
    client.FeatureTick(&quot;ConstructTriangle&quot;);
    // ...
}</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>function constructTriangle(rows) {
    client.featureTick(&quot;ConstructTriangle&quot;);
    // ...
}</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>void Pascal::ConstructTriangle(int rows)
{
    client-&gt;FeatureTick(&quot;ConstructTriangle&quot;);
    // ...
}</code></pre>
        <p>You can place the call to Feature Tick anywhere in your code, they need not have a one-to-one mapping of methods to features.</p>
        <h2 id="feature-starts-and-stops">Feature Starts and Stops</h2>
        <p>A pair of Feature Start and Stops is used to measure not only the occurrence of a feature usage but also the duration of its use. One possible way to use it is to bracket the entire body of the function with a Feature Start and Feature Stop. This
          is useful to time how long a function takes to execute:</p>
        <p class="sample">C# Example</p>
        <pre><code>public void ConstructTriangle(int rows)
{
    client.FeatureStart(&quot;ConstructTriangle&quot;);
    // ...
    client.FeatureStop(&quot;ConstructTriangle&quot;);
}</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>function constructTriangle(rows) {
    client.featureStart(&quot;ConstructTriangle&quot;);
    // ...
    client.featureStop(&quot;ConstructTriangle&quot;);
}</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>void Pascal::ConstructTriangle(int rows)
{
    client-&gt;FeatureStart(&quot;ConstructTriangle&quot;);
    // ...
    client-&gt;FeatureStop(&quot;ConstructTriangle&quot;);
}</code></pre>
        <p>It is important that you use the exact same name in the Start and Stop calls otherwise it will look like two separate features.</p>
        <p>Feature Start and Stop can also be used to determine how much time a user spends using a certain feature.</p>
        <p class="sample">C# Example</p>
        <pre><code>public void EnterTextEditor()
{
    client.FeatureStart(&quot;TextEditor&quot;);
    // ... 
}
public void LeaveTextEditor()
{
    client.FeatureStop(&quot;TextEditor&quot;);
    // ...
}</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>function enterTextEditor() {
    client.featureStart(&quot;TextEditor&quot;);
    // ...
}
function leaveTextEditor() {
    client.featureStop(&quot;TextEditor&quot;);
 // ...
}</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>void MyProgram::EnterTextEditor()
{
    client-&gt;FeatureStart(&quot;TextEditor&quot;);
    // ... 
}
void MyProgram::LeaveTextEditor()
{
    client-&gt;FeatureStop(&quot;TextEditor&quot;);
    // ...
}</code></pre>
        <p>A function can contain any number of Feature Starts and Stops, and there does not have to be a one-to-one mapping of functions to features.</p>
        <h2 id="feature-start-stop-partitioning">Feature Start/Stop Partitioning</h2>
        <p>Feature Starts and Stops are &quot;partitioned&quot;. To demonstrate this, look at this example:</p>
        <ol>
          <li>Thread A does FeatureStart(&quot;foo&quot;);</li>
          <li>Thread B does FeatureStart(&quot;foo&quot;);</li>
          <li>Thread A does FeatureStop(&quot;foo&quot;);</li>
          <li>Thread B does FeatureStop(&quot;foo&quot;);</li>
        </ol>
        <p>A naive implementation would result in Thread A&#39;s stop ending the feature which Thread B started, which is most likely unintended. The default Feature Partitioner will &quot;partition&quot; sets of starts and stops based on Thread ID. So,
          in this case, Thread A&#39;s stop would properly match Thread A&#39;s stop, not Thread B&#39;s.</p>
        <p>However, consider this scenario:</p>
        <ol>
          <li>Thread A does FeatureStart(&quot;bar&quot;);</li>
          <li>Thread B does FeatureStop(&quot;bar&quot;);</li>
        </ol>
        <p>In this scenario, the start and stop would match to each other. If a <code>stop</code> can&#39;t find a <code>start</code> within its own partition, then it will look at all of the tracked <code>start</code>s in the current client instance.</p>
        <h1 id="sending-custom-data">Sending Custom Data</h1>
        <p>You can send custom data to the configured endpoint with any type of message. To send over the data you construct an object to hold key-value pairs. For applications using the WinRT components, you should use a collection of string to object key-value
          pairs that implement the <code>IMap</code> interface. For other applications written in C#/VB.Net, you should use the provided <code>ExtendedKeys</code> class. You can send custom data with any type of message.</p>
        <p>One common use case is to report the arguments a method was called with and what the method will return:</p>
        <p class="sample">C# Example</p>
        <pre><code>public bool ConstructTriangle(int rows)
{
    client.FeatureStart(&quot;ConstructTriangle&quot;);
    bool result = false;
    var keys = new ExtendedKeys(); 
    keys.Add(&quot;rows&quot;, rows);
    client.FeatureStart(&quot;ConstructTriangle&quot;, keys);
    // ...
    keys.Add(&quot;result&quot;, result);
    client.FeatureStop(&quot;ConstructTriangle&quot;, keys);
    return result;
}</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>function ConstructTriangle(rows){
    client.featureStart(&quot;ConstructTriangle&quot;);
    var result = false;
    var keys = new Windows.Foundation.Collections.PropertySet();
    keys[&quot;rows&quot;] = rows;
    client.FeatureStart(&quot;ConstructTriangle&quot;, keys);
    // ...
    keys[&quot;result&quot;] = result;
    client.featureStop(&quot;ConstructTriangle&quot;, keys);
    return result;
}</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>bool Pascal::ConstructTriangle(int rows)
{
    client-&gt;FeatureStart(&quot;ConstructTriangle&quot;);
    bool result = false;
    auto keys = ref new Platform::Collections::Map&amp;lt;String^, Object^&amp;gt;;
    keys-&gt;Insert(&quot;rows&quot;, rows);
    client-&gt;FeatureStart(&quot;ConstructTriangle&quot;, keys);
    // ...
    keys-&gt;Insert(&quot;result&quot;, result);
    client.FeatureStop(&quot;ConstructTriangle&quot;, keys);
    return result;
}</code></pre>
        <p>Values for keys can be either numeric or strings. If you are sending your data to Runtime Intelligence, then the portal will compute some basic statistics for numeric data and provide frequency counts for string values. You can use the same <code>ExtendedKeys</code> structure
          as many times as you need. If you set a key with the same name a second time its original value is replaced.</p>
        <p>ExtendedKeys have some limits. The length of the name for the key is limited to 2000 characters and the value part for strings is limited to 4000 characters. Numeric values can have up to 18 digits of precision with 5 digits to the right of the
          decimal point.</p>
        <h1 id="getting-system-information">Getting System Information</h1>
        <p>The API can generate two types of system information: a system profile and performance information.</p>
        <h2 id="system-profile">System Profile</h2>
        <p>The System Profile generates information about the operating system, its environment, and the hardware. System Profile has varying amounts of support on each platform:</p>
        <ul>
          <li>Classic .NET -- Fully supported</li>
          <li>Windows Phone -- Some support (CPU, Memory, Time zone, Screen, Logical disks, System manufacturer, Model)</li>
          <li>Windows Store -- Some support (CPU, Network, Time zone, Logical disks, System manufacturer, Model)</li>
          <li>Xamarin -- Not supported (is a no-operation)</li>
        </ul>
        <p>You can generate the profile by calling SystemProfile:</p>
        <p class="sample">C# Example</p>
        <pre><code>//...
client.SystemProfile();
//...</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>//...
client.systemProfile();
//...</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>//...
client-&gt;SystemProfile();
//...</code></pre>
        <p>It&#39;s recommended that you only generate one system profile per application run. This is typically done immediately after the Application Start. The System Profile sends back information about many different aspects of the machine running your
          application:</p>
        <ul>
          <li>Processors - Number of processors, clock speeds, manufacturer, and processor ID</li>
          <li>Logical Disks - Number of logical disks, volume name, size, free space, file system</li>
          <li>Memory - Speed, capacity</li>
          <li>Network Adapters - IP address, MAC address</li>
          <li>Domain - Domain name and role</li>
          <li>Display - Name, refresh rate, vertical and horizontal resolution</li>
          <li>Video - Name, memory size, color depth</li>
          <li>Terminal Services - Connections allowed</li>
          <li>Sound - Name, manufacturer</li>
          <li>Modem - Model, device type</li>
        </ul>
        <p>There are two values in the Configuration that affect the data reported in the profile:</p>
        <ul>
          <li>Full Data
            <ul>
              <li>If Full Data is true, then the API spends as much time as needed to collect data. If it is false, then it skips collection of data that potentially takes a significant amount of time to gather. The default is to gather as much information
                as possible</li>
            </ul>
          </li>
          <li>Omit Personal Info
            <ul>
              <li>The default is to report on information that could identify the user and their machine. If Omit Personal Info is set to false the API will skip or mask values such as IP addresses, MAC identifiers, and names that could be used to identify
                the user and their machine.</li>
            </ul>
          </li>
        </ul>
        <h2 id="performance-probe">Performance Probe</h2>
        <p>The Performance Probe reports information about the CPU usage percentage, the amount of memory available to the application, and the amount of memory used by the application. In contrast to the System Profile, the Performance Probe is designed
          to be used in multiple places and called many times in your application. Performance Probe has varying amounts of support on each platform:</p>
        <ul>
          <li>Classic .NET -- Fully supported</li>
          <li>Windows Phone -- No CPU information</li>
          <li>Windows Store -- Not supported (is a no-operation)</li>
          <li>Xamarin -- Not supported (is a no-operation)</li>
        </ul>
        <p>The Performance Probe includes a name so you can track performance information in multiple places in your application:</p>
        <p class="sample">C# Example</p>
        <pre><code>public void ConstructTriangle(int rows)
{
    client.PerformanceProbe(&quot;ConstructTriangle.Starting&quot;);
    // ...
}</code></pre>
        <h1 id="reporting-tampering">Reporting Tampering</h1>
        <p>The API provides a simple way to report tampering of your application using the <code>ReportTamper</code> method.</p>
        <p>Extended Keys can be used to report additional details about the tampering. It is up to you to detect that your application has been tampered with and to call the <code>ReportTamper</code> method.</p>
        <p class="sample">C# Example</p>
        <pre><code>client.ReportTamper();</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>client.reportTamper();</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>client-&gt;ReportTamper();</code></pre>
        <h1 id="reporting-exceptions">Reporting Exceptions</h1>
        <p>The API provides a simple way to report exceptional conditions in your application. The exception reports can be used to track exceptions reported by your application or from third party software. The report can also have user added information
          added to it to aid support staff. And of course you can always add Extended Key information to track application state.</p>
        <h2 id="exception-event-types">Exception Event Types</h2>
        <p>Exception events come in three types:</p>
        <ul>
          <li>Caught
            <ul>
              <li>This represents an exception that is caught by your application. Your code can either be dealing with the exception or is going to pass it up the execution chain. This is the mostly commonly used event type.</li>
            </ul>
          </li>
          <li>Thrown
            <ul>
              <li>This represents an exception that your application is creating. You would use this type for an exception event that is atypical for your application.</li>
            </ul>
          </li>
          <li>Uncaught
            <ul>
              <li>This type is usually used in catch-all handlers and indicates that your application encountered an exception it was not prepared to catch.</li>
            </ul>
          </li>
        </ul>
        <p>In the following example we will show you how to set the event type.</p>
        <h2 id="reporting-details">Reporting Details</h2>
        <p>To pass all the information about the exception we use an <code>ExceptionInfo</code> instance. We must fill it in with information such as:</p>
        <ul>
          <li>Exception type</li>
          <li>Exception name</li>
          <li>Exception message</li>
          <li>Exception stack trace</li>
        </ul>
        <p>Note that this can all be gathered from C# applications by simply passing the relevant <code>System.Exception</code> object into <code>ExceptionInfo</code>. It&#39;s not as easy for non-C# applications:</p>
        <p class="sample">C# Example</p>
        <pre><code>//...
catch (Exception exception)
{
    client.ReportException(new ExceptionInfo(ExceptionType.Caught,
        exception));
}
//...</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>//...
catch (error) {
    var info = new analytics.ExceptionInfo();
    client.reportException(
        analytics.ExceptionInfo.caught(error.name, error.message,
        error.stack));
}
//...</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>//...
catch(Exception^ exception)
{
    client-&gt;ReportException(ExceptionInfo::Caught(
        exception -&gt;GetType()-&gt;FullName, exception-&gt;Message));
} //...</code></pre>
        <p>To indicate the origin of the exception in languages (such as C++) without an official stack trace tool, you can either create a <a href="#binary-information">BinaryInfo</a> instance that will accompany the ExceptionInfo or create your own stacktrace
          string with an accompanying regular expression.</p>
        <p>The regex should break the provided stacktrace string into groups. These groups are:</p>
        <ul>
          <li><code>type</code> -- A string representing the type containing the method in the stacktrace.</li>
          <li><code>meth</code> -- A method in the stacktrace.</li>
          <li><code>sig</code> -- The signature of a method in the stacktrace.</li>
          <li><code>file</code> -- The file where the exception occurred.</li>
          <li><code>line</code> -- The line number where the exception occurred.</li>
        </ul>
        <h1 id="adding-user-details">Adding User Details</h1>
        <p>Many GUI programs can display a message box indicating the error that has occurred to the user. This is an opportunity to have the user enter some additional information that developers can use to diagnose the problem. The ExceptionInfo provides
          a way to attach up to 500 characters of text to the exception report that the user can use to describe the circumstances of the event. It also has a way to pass in contact information, such as a user name or email address.</p>
        <p class="sample">C# Example</p>
        <pre><code>//...
catch (Exception exception)
{
    client.ReportException(new ExceptionInfo(ExceptionType.Caught,
        exception, contact, comment));
}
//...</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>//...
catch (error) {
    var info = new analytics.ExceptionInfo();
    client.reportException(
        analytics.ExceptionInfo.caught(error.name,
        Error.message, error.stack, &quot;&quot;, contact, comment));
}
//...</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>//...
catch(Exception^ exception)
{
    client-&gt;ReportException(ExceptionInfo::Caught(
        exception -&gt;GetType()-&gt;FullName, exception-&gt;Message, &quot;&quot;, &quot;&quot;,
        contact, comment));
} //...</code></pre>
        <h1 id="advanced-configuration">Advanced Configuration</h1>
        <h2 id="user-opt-in">User Opt-In</h2>
        <p>Your application should allow the user to decide if analytics data is gathered or not. The API provides two ways to control the user opting-in to analytics gathering.</p>
        <p>The first way to tell the API about the user&#39;s opt-in is via the Configuration. You use this way when your application stores the user&#39;s previous selection somewhere:</p>
        <p class="sample">C# Example</p>
        <pre><code>var configuration = new Configuration();
configuration.OptIn = GetSavedOptInState();
//...
var client = new PAClient(configuration);</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>var configuration = new analytics.Configuration();
configuration.optIn = getSavedOptInState();
//...
var client = new analytics.PAClient(configuration, null);</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>var configuration = ref new Configuration();
configuration-&gt;OptIn = GetSavedOptInState();
//...
var client = ref new PAClient(configuration, nullptr);</code></pre>
        <p>If the opt-in value is set to false, then calls to ApplicationStart will not start the API.</p>
        <p>The second way the opt-in option can be changed is by talking directly to the API at runtime. You would use this if your application has a dialog that lets the user change the opt-in status after an Application Start:</p>
        <p class="sample">C# Example</p>
        <pre><code>client.SetSessionOptIn(true);</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>client.setSessionOptIn(true);</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>client-&gt;SetSessionOptIn(true);</code></pre>
        <p>If the opt-in state changes from false to true the API will do an automatic Application Start and analytics will start being gathered. Note that this behavior only occurs if a properly configured Application Start has previously been tried and
          has failed due to the opt-in status.</p>
        <p>There are a couple of things to note about the opt-in state. If the Application Start is skipped because of the opt-in state, the API may still send messages that were previously gathered and stored offline. Once it is done sending that data it
          will go back to the stopped state. If you change the opt-in state from true to false the API does not immediately shut down. Instead it stops gathering analytics by ignoring messages like Feature Tick et. al., but will send any previously created
          messages. Opt-In does not affect the sending of Application Stop messages if the API was previously started with Opt-In set to true, or if the API was started by Opt-In being set to true.</p>
        <h2 id="information-about-your-application">Information About Your Application</h2>
        <p>There is much more information you can send to the configured endpoint about your application than just its application ID.</p>
        <ul>
          <li>Name
            <ul>
              <li>The name of the application. The Runtime Intelligence portal uses this as the default display name for the application, but you can rename it for display purposes.</li>
            </ul>
          </li>
          <li>Type
            <ul>
              <li>A user defined application type.</li>
            </ul>
          </li>
          <li>Version
            <ul>
              <li>A version string for the application. Although no specific format is defined a dotted numeric representation is recommended.</li>
            </ul>
          </li>
          <li>Instance ID
            <ul>
              <li>An identifier for the instance of the application, such as a serial number. No specific format is defined.</li>
            </ul>
          </li>
        </ul>
        <p>These values along with the Application ID are used to define a particular application in the Runtime Intelligence Portal. The only value that you should change over time is the Version string.</p>
        <p class="sample">C# Example</p>
        <pre><code>//...    </code></pre>
        <p>var configuration = new Configuration(&quot;7D2B02E0-064D-49A0-BC1B-4BE4381C62D3&quot;, &quot;21EC2020-CCCC-1069-A2DD-08002B30309D&quot;); configuration.ApplicationName = &quot;C# Sample App&quot;;
          <br>configuration.ApplicationType = &quot;C# Sample&quot;;
          <br>configuration.ApplicationVersion = &quot;1.0&quot;; configuration.InstanceID = GetSerialNumber(); //...
        </p>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>//...
var configuration = new analytics.Configuration();
configuration.companyID = &quot;7D2B02E0-064D-49A0-BC1B-4BE4381C62D3&quot;
configuration.applicationID = &quot;21EC2020-CCCC-1069-A2DD-08002B30309D&quot;
configuration.applicationName = &quot;JavaScript Sample App&quot;;
configuration.applicationType = &quot;JavaScript Sample&quot;;
configuration.applicationVersion = &quot;1.0&quot;;
configuration.applicationID = getSerialNumber();
//...</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>//...
auto configuration = ref new Configuration();
configuration-&gt;CompanyID = &quot;7D2B02E0-064D-49A0-BC1B-4BE4381C62D3&quot;
configuration-&gt;ApplicationID = &quot;21EC2020-CCCC-1069-A2DD-08002B30309D&quot;
configuration-&gt;ApplicationName = &quot;C++ Sample App&quot;; 
configuration-&gt;ApplicationType = &quot;C++ Sample&quot;;
configuration-&gt;ApplicationVersion = &quot;1.0&quot;;
configuration-&gt;ApplicationID = GetSerialNumber();
//...</code></pre>
        <h2 id="binary-information">Binary Information</h2>
        <p>In addition to tracking general application details, you may want to track assembly level details. <code>BinaryInfo</code> can be used for this functionality.</p>
        <p>Every type of message is capable of sending a <code>BinaryInfo</code> object. With this you can track details such as:</p>
        <ul>
          <li>Assembly name and version which sent the message</li>
          <li>Class and Method name which sent the message</li>
          <li>Last modified date on the assembly sending the message</li>
        </ul>
        <p>Due to limitations of some platforms, there are a few different methods you can use to get an automatically populated BinaryInfo</p>
        <ul>
          <li>Use <code>PreEmptive.Analytics.Common.BinaryInfo.GetCurrent()</code>
            <ul>
              <li>This only populates assembly name and version of the direct method which calls it.</li>
              <li>This can be used from any .Net language (ie, not WinRT languages like C++ and JavaScript)</li>
            </ul>
          </li>
          <li>Use (for supported platforms) <code>Platform.GetCurrentBinaryInfo()</code>
            <ul>
              <li>In general, these methods provide binary information in an automated way that is as complete as the platform allows</li>
              <li>Currently, only classic .NET has an implementation here</li>
            </ul>
          </li>
          <li>Use <code>PreEmptive.Analytics.WinRT.BinaryInfo.GetCurrent()</code>
            <ul>
              <li>This only populates assembly name and version from the Windows Store package &quot;name&quot; (a GUID) and the package version</li>
            </ul>
          </li>
        </ul>
        <h2 id="storing-data-offline">Storing Data Offline</h2>
        <p>By default the API will try to send messages directly to the configured endpoint. If there is no internet connection or there is a problem reaching the server it will save the data locally for later transmission.</p>
        <p>You can control this behavior with the <code>Configuration</code> instance before Application Start. The settings that control the API&#39;s behavior are:</p>
        <ul>
          <li>Offline
            <ul>
              <li>This indicates that the API will not attempt to send messages to the endpoint (and instead save them to offline storage). By default the API is &quot;online&quot;.</li>
            </ul>
          </li>
          <li>SupportOfflineStorage
            <ul>
              <li>This tell the API if it is allowed to store data locally. By default the API will store data locally.</li>
            </ul>
          </li>
        </ul>
        <p>Changing values in the <code>StartupConfiguration</code> instance will not have any effect while an application run is active.</p>
        <p>There is also an option called <code>SendDisabled</code>. An initial value for it can be set on the <code>FlowController</code> instance. This differs from Offline in that it is a temporary condition and can be changed by calling the <code>SetSendDisabled</code> method
          in the API instance while the application run is active. We will talk more about that in <a href="#controlling-the-transmission-window">Controlling the Transmission Window</a>.</p>
        <h2 id="controlling-data-transmission">Controlling Data Transmission</h2>
        <p>The API doesn&#39;t send messages immediately to the configured endpoint, instead it bundles them up into groups. The number of message that make up a group is based on a combination of the maximum size of the message queue, how quickly your application
          is generating messages, and how long you want to keep messages in memory. All of this behavior is determined by the Flow Controller passed into Application Start.</p>
        <h2 id="field-size-limits">Field Size Limits</h2>
        <p>It is assumed that the server enforces certain size limitations on specific fields. For instance, feature tick names may be truncated to 50 characters by the endpoint because its database is only configured to allow 50 characters. To avoid sending
          data which will not be utilized and/or may cause problems for the endpoint, the API supports limiting the size of specific XML attributes.</p>
        <p>New size limits can be created by using the <code>DictionaryAttributeLimiter</code> class from C#/.NET.</p>
        <p class="sample">C# Example</p>
        <p>var limiter=new DictionaryAttributeLimiter(); limiter.Set(&quot;feature&quot;, &quot;name&quot;, 100); //set the limit of feature names to 100 characters MyConfiguration.AttributeLimiter=limiter; var client = new PAClient(MyConfiguration);</p>
        <p>The <code>DictionaryAttributeLimiter</code> is only exposed in C#/.NET, not in WinRT. However, we provide four built in limiters for our official endpoints:</p>
        <ul>
          <li><code>EndpointAttributeLimits.RI</code> -- For the Runtime Intelligence portal</li>
          <li><code>EndpointAttributeLimits.PATFS</code> -- For the PreEmptive Analytics for TFS endpoint</li>
          <li><code>EndpointAttributeLimits.Common</code> -- The least common denominator between RI and PATFS</li>
          <li><code>EndpointAttributeLimits.None</code> -- No limits</li>
        </ul>
        <p>By default, the Common limiter is used for the field size limits. It uses the least common denominator between RI and PATFS. For instance, Runtime Intelligence has a company name limit of 100 characters. PA for TFS has a company name limit of
          600 characters. So, by default we limit the company name to 100 characters to minimize bandwidth needed. Note that both endpoints can handle larger company names, but the server will truncate the name to its respective limit.</p>
        <p>These can be set from C# and from WinRT-supported languages. Here are examples of using the RI field size limits from C# and WinRT languages:</p>
        <p class="sample">C# Example</p>
        <pre><code>configuration.AttributeLimiter = 
PreEmptive.Analytics.Common.EndpointAttributeLimits.RI; </code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>configuration.attributeLimiter = 
PreEmptive.Analytics.WinRT.EndpointAttributeLimits.ri; </code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>configuration-&gt;AttributeLimiter = 
PreEmptive::Analytics::WinRT::EndpointAttributeLimits::RI;</code></pre>
        <h2 id="shutdown-time-limits">Shutdown Time Limits</h2>
        <p><code>ApplicationStop</code> is blocking/synchronous by default on some platforms and asynchronous on others:</p>
        <ul>
          <li>Classic .NET -- synchronous</li>
          <li>Windows Store Apps -- synchronous</li>
          <li>Windows Phone Apps -- synchronous</li>
          <li>Xamarin iOS -- synchronous</li>
          <li>Xamarin Android -- asynchronous with Session Extension</li>
        </ul>
        <p>To keep from holding the application open and/or failing certification, there are configurable shutdown time limits.</p>
        <ul>
          <li><code>StopTimeout</code> -- The absolute timeout after which the synchronous <code>ApplicationStop</code> methods will return, no matter what.</li>
          <li><code>NeededTimeForSavingAtStop</code> -- When the time for stopping the API approaches <code>StopTimeout</code>, it will interrupt all pending transmissions early so that they can be saved to offline storage. If offline storage is disabled, then
            the API will &quot;fire and forget&quot; all remaining messages at this point to attempt to get as much data to the endpoint as possible.</li>
        </ul>
        <p>By default, <code>StopTimeout</code> is 10 seconds and <code>NeededTimeForSavingAtStop</code> is 2 seconds. So, after 8 seconds have passed within <code>ApplicationStop</code>, it will get a signal that it needs to stop trying to transmit messages
          and save them to offline storage OR to fire and forget them before the process is destroyed.</p>
        <p>These application stop behavior properties are contained within <code>Configuration.StopBehavior</code> on most platforms. It is just contained within <code>Configuration</code> on WinRT.</p>
        <h2 id="api-language-interoperability">API Language Interoperability</h2>
        <p>Analytics can be added to applications created in multiple languages. The PreEmptive Analytics API is available for several languages, but only one can control the Application Start and Stop at a time. The API that starts first controls the scope
          of the application run and has APIs implemented in other language run in a subordinate fashion. This is done by setting the <code>DefaultSession</code> in the <code>Configuration</code> class. You can retrieve the generated session GUID by calling <code>PAClient.GetActiveDefaultSession()</code>.</p>
        <h2 id="session-extension-window">Session Extension Window</h2>
        <p>On some mobile platforms, it is desirable to not immediately stop an API instance when the application is put into the background. Session Extension is a feature that allows the API to only stop after a set amount of time of the target application
          being in the background. This is enabled by setting the <code>SessionExtensionWindow</code> property to something greater than 0. With this enabled, when the API receives an ApplicationStop, it will kick off a timer. If an ApplicationStart is
          received before this timer expires, the API will not be stopped. If an ApplicationStart is not received, however, the API will stop as normal. An example use case is if you have instrumented a phone application. If the user is actively using
          your application, checks a text message, and quickly switches back to your application, it is probably desirable for this to be considered one session, not two.</p>
        <p>This feature also allows for the compensation of out-of-order application start and stop requests. If the API is already started and an extra ApplicationStart is received, followed soon after by an ApplicationStop, it is assumed that the calls
          are out of order and the stop will be ignored. This means the API won&#39;t stop from such a condition, and the sent data will continue to look like a single session. This feature is particularly useful for properly instrumenting a Xamarin Android
          application, since Android Activities have an inverted and difficult to work with life cycle.</p>
        <p>When using this feature, you must be careful to avoid accidental message loss. You may want to do a session-extension enabled ApplicationStop when the user switches away from your application. However, when the operating system is about to terminate
          your application, it&#39;s not desirable to wait and see if the application will be brought back to the foreground. In this case it is desirable to use the <code>immediate</code> parameter of <code>ApplicationStop</code> to cause the API to ignore
          the session extension feature and instead immediately stop.</p>
        <p class="sample">C# Example</p>
        <pre><code>client.ApplicationStop(immediate: true);</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>client.applicationStop(null, null, true); //last parameter is `immediate`</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>client-&gt;ApplicationStop(nullptr, nullptr, true); //last parameter is `immediate`</code></pre>
        <p>Currently, Session Extension is enabled by default and set to 60 seconds on the Xamarin Android. It is disabled by default on all other platforms.</p>
        <h1 id="invalid-characters">Invalid Characters</h1>
        <p>The API automatically escapes all non-ASCII characters. It also discards characters which are non-escapable according to the XML specification. The API currently does not support characters which require more than 1 word (2 bytes) to represent
          in UTF-16 (codepoints greater than U+FFFF). These unsupported characters may be sent corrupted or discarded.</p>
        <h1 id="the-flow-controller">The Flow Controller</h1>
        <p>The first items we will look at in the Flow Controller are those controlling the in-memory queue size. This is where messages are held before being sent to the endpoint or to local storage. There are two controls:</p>
        <ul>
          <li><code>QueueSize</code>
            <ul>
              <li>This is the absolute maximum number of messages that will be held in memory. If the queue overflows the oldest messages will be discarded. The default value is 30.</li>
            </ul>
          </li>
          <li><code>HighWater</code>
            <ul>
              <li>This is the point in the queue where the API will try to bundle up the messages for transmission or storage. The space between the HighWater and the QueueSize gives the API room to handle applications sending messages at a rapid pace. The
                default value is 20.</li>
            </ul>
          </li>
        </ul>
        <p>When you set the <code>QueueSize</code> the <code>HighWater</code> property is automatically adjusted to be 1/3 less than the size. You may want to adjust these values if your application can send rapid bursts of messages.</p>
        <p>The next two items control how often the API will try to flush the queue regardless of how many messages have accumulated.</p>
        <ul>
          <li><code>MaximumInterval</code>
            <ul>
              <li>How long, in milliseconds, will a message sit in the queue before the API will attempt to transmit it or store it locally. The default value is 30000.</li>
            </ul>
          </li>
          <li><code>MinimumInterval</code>
            <ul>
              <li>The minimum time, in milliseconds, that the API will wait between queue checks. The default value is 1.</li>
            </ul>
          </li>
        </ul>
        <p>Adjusting these values requires care. Having a <code>MaximumInterval</code> that is too large can cause the API to hang on to memory used to store messages - this can be exacerbated by having a large <code>QueueSize</code>. Setting it too small can
          steal time from your application.</p>
        <p>The actual time between checks is determined by the <code>FlowController</code> and the rate at which your application is sending messages. This brings us to the next two properties:</p>
        <ul>
          <li><code>Gain</code>
            <ul>
              <li>The rate at which the queue checking interval is adjusted when there are messages in the queue. This is a percentage. If you set it to 100, then this means that when there are messages in the queue, the queue checking interval will decrease
                (become more frequent) by 100% when there are messages. The interval will never be more frequent than <code>MinimumInterval</code>. The default is 66.</li>
            </ul>
          </li>
          <li><code>QuietGain</code>
            <ul>
              <li>The rate at which the queue checking interval is adjusted when there are no messages in the queue. This value controls how quickly the interval works its way back to MaximumInterval when there are no queued messages. You can use values from
                1 to 100. The default value is 33.</li>
            </ul>
          </li>
        </ul>
        <p>Finally, there are two properties that let the <code>FlowController</code> handles transmission problems:</p>
        <ul>
          <li><code>MaximumSequentialFailureCount</code>
            <ul>
              <li>The <code>FlowController</code> keeps track of the number of times the endpoint cannot be contacted due to networking issues. Every time the Server is contacted this count is reset. When the count exceeds the set value the network is considered
                down for a period of time. This keeps the API from trying to use network resources when the chance of success is low. The default value is 3.</li>
            </ul>
          </li>
          <li><code>RetryTimeout</code>
            <ul>
              <li>Once we reach the failure count the API determines a retry time based on this value. It won&#39;t try to send to the configured endpoint again until this timeout has elapsed. The default value is 60 seconds.</li>
            </ul>
          </li>
        </ul>
        <h2 id="controlling-the-transmission-window">Controlling the Transmission Window</h2>
        <p>The Flow Controller uses the previously mentioned values to adjust how often it will empty the in memory queue of messages. Although this takes place on a background thread with a lower priority it still can happen at a time where your application
          is doing something critical. The API provides a way to control when the transmission can take place.</p>
        <p>If you have places in your application where you need to prevent the API from sending messages you can use the Send Disabled feature:</p>
        <p class="sample">C# Example</p>
        <pre><code>client.SetSendDisabled(true);
// Time critical code here
client.SetSendDisabled(false);</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>client.setSendDisabled(true);
// Time critical code here
client.setSendDisabled(false);</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>client-&gt;SetSendDisabled(true);
// Time critical code here
client-&gt;SetSendDisabled(false);</code></pre>
        <p>Another way to use Send Disabled is to only allow sending when your application is in an idle state, for example sitting at a menu screen. In this case you would want to start up the API in the disabled state, which you can do with the <code>FlowController</code> instance:</p>
        <p class="sample">C# Example</p>
        <pre><code>var flowController = new FlowController();
flowController.SendDisabled = true;
client.ApplicationStart(null, null, flowController);
// When you enter an idle state
client.SetSendDisabled(false);
// When you are busy again
client.SetSendDisabled(true);</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>var flowController = new analytics.FlowController();
flowController.sendDisabled = true;
client.applicationStart(null, null, flowController);
// When you enter an idle state
client.setSendDisabled(false);
// When you are busy again
client.setSendDisabled(true);</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>auto flowController = ref new FlowController();
flowController.SendDisabled = true;
client-&gt;ApplicationStart(nullptr, nullptr, flowController);
// When you enter an idle state
client-&gt;SetSendDisabled(false);
// When you are busy again
client-&gt;SetSendDisabled(true);</code></pre>
        <p>The last way that you can control the sending of messages is by telling the API that it should flush any queued messages right away. This is done with the <code>SendMessages</code> method:</p>
        <p class="sample">C# Example</p>
        <pre><code>client.SendMessages();</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>client.sendMessages();</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>client-&gt;SendMessages();</code></pre>
        <h2 id="time-to-live">Time To Live</h2>
        <p>If you send many messages and it&#39;s a fairly rare occurrence that the user is connected to the internet, then it&#39;s possible that messages could consume an ever-increasing amount of disk space. The API addresses this problem by exposing
          a set of criteria that control how old messages may be deleted. There are two properties to configure this behavior:</p>
        <ul>
          <li><code>MinimumFailureCount</code>
            <ul>
              <li>The minimum number of times a message will attempt to be sent. The default is 150 times</li>
            </ul>
          </li>
          <li><code>MinimumTimeToLive</code>
            <ul>
              <li>The minimum amount of seconds a message must exist before being eligible for deletion. The default is 3 days, or <code>60*60*24*3</code>
              </li>
            </ul>
          </li>
        </ul>
        <p>Both of these conditions must be met before a message is eligible for deletion.</p>
        <p>These properties are also retroactive. So, if you were to set these to very high values which impacted a user&#39;s experience(by using significant disk space), you could publish an update to your application with lower values for these properties
          and old messages qualifying with the new properties would begin to immediately be deleted</p>
        <p>For ease of use, these properties exist in both <code>Configuration</code> and <code>FlowController</code>. See <a href="#interactions-with-configuration">Interactions With Configuration</a> for more details about this.</p>
        <h2 id="batch-size-limits">Batch Size Limits</h2>
        <p>Most servers have limitations on how large of a request they can process. Because of this, the API has support for splitting requests that would surprass the server&#39;s limits. If a single message is larger than this size, then it will be discarded.</p>
        <p>This is configurable by using the <code>MaximumBatchSize</code> property on the <code>Configuration</code> or the <code>FlowController</code> instance. By default it is set to <code>4Mb - 4Kb</code>. We leave 4K of extra space so that there is plenty
          of room for HTTP headers</p>
        <p>This property is retroactive. So, if you had this value set to such a high value that the configured endpoint couldn&#39;t handle such a large request, you could publish an update to your application with appropriate values and the old message
          batches would then be split to conform to the new value.</p>
        <h2 id="interactions-with-configuration">Interactions With Configuration</h2>
        <p>It&#39;s not expected that most people will need all of the control that creating a <code>FlowController</code> allows. Because of this, many properties are duplicated among <code>Configuration</code> and <code>FlowController</code>, including:</p>
        <ul>
          <li><code>Offline</code>
          </li>
          <li><code>SupportOfflineStorage</code>
          </li>
          <li><code>MinimumTimeToLive</code>
          </li>
          <li><code>MinimumFailureCount</code>
          </li>
          <li><code>MaximumBatchSize</code>
          </li>
        </ul>
        <p>This is so that creating a new <code>FlowController</code> instance isn&#39;t normally required for more common configuration options. If you do create a new <code>FlowController</code> instance however, then the properties from the <code>Configuration</code> instance <strong>are not used</strong> for
          these duplicated values. This is because the API also allow the creation of a custom flow controller using the <code>IFlowController</code> interface, which is disconnected from the default implementation and has these properties exposed at a
          more abstract level.</p>
        <p>Here is an example of this behavior:</p>
        <p class="sample">C# Example</p>
        <pre><code>config.Offline=true;
var flow=new FlowController();
flow.Offline=false; //This is the actual value that will be used!
var client = new PAClient(configuration);
client.ApplicationStart(null, null, null, flow); 
//the API will be &quot;online&quot; at this point, not &quot;offline&quot;</code></pre>
        <h1 id="client-side-logging">Client-Side Logging</h1>
        <p>The API has the ability to do client-side logging for debugging purposes. This is accomplished by passing a logger instance into the client constructor. You can either use the provided <code>Logger</code> implementations or create your own by implementing
          the <code>ILogger</code> interface. This allows you to handle the logging information in any way you want.</p>
        <p class="sample">C# Example</p>
        <pre><code>var client = new PAClient(configuration, new Logger(LoggingLevel.Info));</code></pre>
        <p class="sample">JavaScript Windows Store Example</p>
        <pre><code>var client = new analytics.PAClient(configuration, 
    new Logger(analytics.LoggingLevel.info()));</code></pre>
        <p class="sample">C++ Windows Store Example</p>
        <pre><code>auto client = 
    ref new PAClient(configuration, ref new Logger(LoggingLevel::Info()));</code></pre>
        <p>The provided platform specific loggers output the logging information to a file (PALogFile.txt). This file is located in different places depending on the platform. For standard .NET applications, the file is placed in the same directory as the
          executable. On the phone platform, the file is placed in the root directory of isolated storage, and for WinRT it is in the LocalState directory where the package is installed.</p>
        <p>Note that since JavaScript does not have the notion of classes, creating your own logger is not as straightforward as other WinRT languages. In order to implement your own logger for a JavaScript WinRT solution, create a Windows Runtime Component
          in another language, such as C#, and use that implementation in your JavaScript project.</p>
      </div>
    </div>
  </body>
</html>
